layerAverage
{
    libs ("libutilityFunctionObjects.so");
    type coded;
    name layerAverage;
    enabled yes;
    writeControl writeTime;

    codeInclude
    #{
        #include "fvCFD.H"
        #include <fstream>
        #include <map>
    #};

    codeWrite
    #{

    // Read parameters from settings file
    std::ifstream settingsFile("overview");
    std::map<word, scalar> params;
    
    word key;
    scalar value;
    while (settingsFile >> key >> value)
    {
        params[key] = value;
    }
    settingsFile.close();

    label nLayers = label(params["n_z"]);
    
    // Lookup fields
    const volScalarField& S = mesh().lookupObject<volScalarField>("C_S");
    const volScalarField& CO2 = mesh().lookupObject<volScalarField>("C_CO2");
    const volVectorField& C = mesh().C();
    const scalarField& V = mesh().V();
    
    // Get minimum and maximum z coordinates
    scalar minZ = GREAT;
    scalar maxZ = -GREAT;
    forAll(C, cellI)
    {
        scalar z = C[cellI].component(2);
        minZ = min(minZ, z);
        maxZ = max(maxZ, z);
    }
    
    reduce(minZ, minOp<scalar>());
    reduce(maxZ, maxOp<scalar>());
    
    // Create list of all cell z-coordinates and volumes for sorting
    labelList cellOrder(C.size());
    forAll(cellOrder, i) cellOrder[i] = i;
    
    // Sort cells by z-coordinate
    Foam::sort(cellOrder, [&](label a, label b) 
    {
        return C[a].component(2) < C[b].component(2);
    });
    
    // Calculate cells per layer (approximately)
    label totalCells = returnReduce(C.size(), sumOp<label>());
    label cellsPerLayer = max(1, totalCells / nLayers);
    
    // Initialize arrays for each layer
    scalarField layerS_sum(nLayers, 0.0);
    scalarField layerCO2_sum(nLayers, 0.0);
    scalarField layerVolume(nLayers, 0.0);
    scalarField layerZ_sum(nLayers, 0.0);
    
    // Accumulate values for each layer based on sorted cell distribution
    label globalCellCount = 0;
    forAll(cellOrder, i)
    {
        label cellI = cellOrder[i];
        scalar z = C[cellI].component(2);
        
        // Determine layer based on cumulative cell count
        label layerIdx = min(globalCellCount / cellsPerLayer, nLayers - 1);
        globalCellCount++;
        
        layerS_sum[layerIdx] += S[cellI] * V[cellI];
        layerCO2_sum[layerIdx] += CO2[cellI] * V[cellI];
        layerVolume[layerIdx] += V[cellI];
        layerZ_sum[layerIdx] += z * V[cellI];
    }
    
    // Sum across all processors
    if (Pstream::parRun())
    {
        reduce(layerS_sum, sumOp<scalarField>());
        reduce(layerCO2_sum, sumOp<scalarField>());
        reduce(layerVolume, sumOp<scalarField>());
        reduce(layerZ_sum, sumOp<scalarField>());
    }
    
    // Write data to file in time directory
    if (Pstream::master())
    {
        fileName outputFile = "layerAveragedData";
        std::ofstream out(outputFile);
        out.precision(12);
        out << "# z S CO2" << std::endl;
        
        forAll(layerS_sum, layerIdx)
        {
            if (layerVolume[layerIdx] > VSMALL)
            {
                // Volume-weighted average z position for this layer
                scalar z = layerZ_sum[layerIdx] / layerVolume[layerIdx];
                scalar S_avg = layerS_sum[layerIdx] / layerVolume[layerIdx];
                scalar CO2_avg = layerCO2_sum[layerIdx] / layerVolume[layerIdx];
                
                out << z << " " << S_avg << " " << CO2_avg << std::endl;
            }
        }
        out.close();
        
        Info << "Layer-averaged data written to " << outputFile << endl;
    }
    
    #};
}